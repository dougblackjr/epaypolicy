<?php
/**
 * TransactionsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Tns\EpayPolicy
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * epay3 API 1.0
 *
 * This API supports the processing of credit card and eCheck/ACH payments.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@epay3.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.6.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Tns\EpayPolicy\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Tns\EpayPolicy\ApiException;
use Tns\EpayPolicy\Configuration;
use Tns\EpayPolicy\HeaderSelector;
use Tns\EpayPolicy\ObjectSerializer;

/**
 * TransactionsApi Class Doc Comment
 *
 * @category Class
 * @package  Tns\EpayPolicy
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class TransactionsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'transactionsAuthorize' => [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/x-www-form-urlencoded',
        ],
        'transactionsGet' => [
            'application/json',
        ],
        'transactionsPost' => [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/x-www-form-urlencoded',
        ],
        'transactionsRefund' => [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/x-www-form-urlencoded',
        ],
        'transactionsSearch' => [
            'application/json',
        ],
        'transactionsVoid' => [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/x-www-form-urlencoded',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation transactionsAuthorize
     *
     * Creates an authorization on a credit card.
     *
     * @param  \Tns\EpayPolicy\Model\PostAuthorizeTransactionRequestModel $post_authorize_transaction_request_model The details of the transaction to be authorized. (required)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsAuthorize'] to see the possible values for this operation
     *
     * @throws \Tns\EpayPolicy\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function transactionsAuthorize($post_authorize_transaction_request_model, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsAuthorize'][0])
    {
        $this->transactionsAuthorizeWithHttpInfo($post_authorize_transaction_request_model, $impersonation_account_key, $contentType);
    }

    /**
     * Operation transactionsAuthorizeWithHttpInfo
     *
     * Creates an authorization on a credit card.
     *
     * @param  \Tns\EpayPolicy\Model\PostAuthorizeTransactionRequestModel $post_authorize_transaction_request_model The details of the transaction to be authorized. (required)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsAuthorize'] to see the possible values for this operation
     *
     * @throws \Tns\EpayPolicy\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function transactionsAuthorizeWithHttpInfo($post_authorize_transaction_request_model, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsAuthorize'][0])
    {
        $request = $this->transactionsAuthorizeRequest($post_authorize_transaction_request_model, $impersonation_account_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tns\EpayPolicy\Model\PostAuthorizeTransactionResponseModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation transactionsAuthorizeAsync
     *
     * Creates an authorization on a credit card.
     *
     * @param  \Tns\EpayPolicy\Model\PostAuthorizeTransactionRequestModel $post_authorize_transaction_request_model The details of the transaction to be authorized. (required)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsAuthorize'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transactionsAuthorizeAsync($post_authorize_transaction_request_model, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsAuthorize'][0])
    {
        return $this->transactionsAuthorizeAsyncWithHttpInfo($post_authorize_transaction_request_model, $impersonation_account_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation transactionsAuthorizeAsyncWithHttpInfo
     *
     * Creates an authorization on a credit card.
     *
     * @param  \Tns\EpayPolicy\Model\PostAuthorizeTransactionRequestModel $post_authorize_transaction_request_model The details of the transaction to be authorized. (required)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsAuthorize'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transactionsAuthorizeAsyncWithHttpInfo($post_authorize_transaction_request_model, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsAuthorize'][0])
    {
        $returnType = '';
        $request = $this->transactionsAuthorizeRequest($post_authorize_transaction_request_model, $impersonation_account_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'transactionsAuthorize'
     *
     * @param  \Tns\EpayPolicy\Model\PostAuthorizeTransactionRequestModel $post_authorize_transaction_request_model The details of the transaction to be authorized. (required)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsAuthorize'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function transactionsAuthorizeRequest($post_authorize_transaction_request_model, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsAuthorize'][0])
    {

        // verify the required parameter 'post_authorize_transaction_request_model' is set
        if ($post_authorize_transaction_request_model === null || (is_array($post_authorize_transaction_request_model) && count($post_authorize_transaction_request_model) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_authorize_transaction_request_model when calling transactionsAuthorize'
            );
        }



        $resourcePath = '/api/v1/transactions/authorize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($impersonation_account_key !== null) {
            $headerParams['impersonationAccountKey'] = ObjectSerializer::toHeaderValue($impersonation_account_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', 'application/xml', 'text/xml', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_authorize_transaction_request_model)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_authorize_transaction_request_model));
            } else {
                $httpBody = $post_authorize_transaction_request_model;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation transactionsGet
     *
     * Retrieves the details of a transaction.
     *
     * @param  int $id The Id of the transaction. (required)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsGet'] to see the possible values for this operation
     *
     * @throws \Tns\EpayPolicy\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Tns\EpayPolicy\Model\GetTransactionResponseModel|array<string,object>
     */
    public function transactionsGet($id, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsGet'][0])
    {
        list($response) = $this->transactionsGetWithHttpInfo($id, $impersonation_account_key, $contentType);
        return $response;
    }

    /**
     * Operation transactionsGetWithHttpInfo
     *
     * Retrieves the details of a transaction.
     *
     * @param  int $id The Id of the transaction. (required)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsGet'] to see the possible values for this operation
     *
     * @throws \Tns\EpayPolicy\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Tns\EpayPolicy\Model\GetTransactionResponseModel|array<string,object>, HTTP status code, HTTP response headers (array of strings)
     */
    public function transactionsGetWithHttpInfo($id, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsGet'][0])
    {
        $request = $this->transactionsGetRequest($id, $impersonation_account_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Tns\EpayPolicy\Model\GetTransactionResponseModel' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tns\EpayPolicy\Model\GetTransactionResponseModel' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tns\EpayPolicy\Model\GetTransactionResponseModel', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('array<string,object>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,object>' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,object>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Tns\EpayPolicy\Model\GetTransactionResponseModel';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tns\EpayPolicy\Model\GetTransactionResponseModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,object>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation transactionsGetAsync
     *
     * Retrieves the details of a transaction.
     *
     * @param  int $id The Id of the transaction. (required)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transactionsGetAsync($id, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsGet'][0])
    {
        return $this->transactionsGetAsyncWithHttpInfo($id, $impersonation_account_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation transactionsGetAsyncWithHttpInfo
     *
     * Retrieves the details of a transaction.
     *
     * @param  int $id The Id of the transaction. (required)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transactionsGetAsyncWithHttpInfo($id, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsGet'][0])
    {
        $returnType = '\Tns\EpayPolicy\Model\GetTransactionResponseModel';
        $request = $this->transactionsGetRequest($id, $impersonation_account_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'transactionsGet'
     *
     * @param  int $id The Id of the transaction. (required)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function transactionsGetRequest($id, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling transactionsGet'
            );
        }



        $resourcePath = '/api/v1/transactions/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($impersonation_account_key !== null) {
            $headerParams['impersonationAccountKey'] = ObjectSerializer::toHeaderValue($impersonation_account_key);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', 'application/xml', 'text/xml', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation transactionsPost
     *
     * Processes a sale transaction for either ACH or credit card.
     *
     * @param  \Tns\EpayPolicy\Model\PostTransactionRequestModelV1 $post_transaction_request_model The details of the transaction to be processed. In the response, the Id of the created transaction is the last part of the URI in the location header attribute. (required)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsPost'] to see the possible values for this operation
     *
     * @throws \Tns\EpayPolicy\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function transactionsPost($post_transaction_request_model, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsPost'][0])
    {
        $this->transactionsPostWithHttpInfo($post_transaction_request_model, $impersonation_account_key, $contentType);
    }

    /**
     * Operation transactionsPostWithHttpInfo
     *
     * Processes a sale transaction for either ACH or credit card.
     *
     * @param  \Tns\EpayPolicy\Model\PostTransactionRequestModelV1 $post_transaction_request_model The details of the transaction to be processed. In the response, the Id of the created transaction is the last part of the URI in the location header attribute. (required)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsPost'] to see the possible values for this operation
     *
     * @throws \Tns\EpayPolicy\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function transactionsPostWithHttpInfo($post_transaction_request_model, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsPost'][0])
    {
        $request = $this->transactionsPostRequest($post_transaction_request_model, $impersonation_account_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tns\EpayPolicy\Model\PostTransactionResponseModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation transactionsPostAsync
     *
     * Processes a sale transaction for either ACH or credit card.
     *
     * @param  \Tns\EpayPolicy\Model\PostTransactionRequestModelV1 $post_transaction_request_model The details of the transaction to be processed. In the response, the Id of the created transaction is the last part of the URI in the location header attribute. (required)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transactionsPostAsync($post_transaction_request_model, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsPost'][0])
    {
        return $this->transactionsPostAsyncWithHttpInfo($post_transaction_request_model, $impersonation_account_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation transactionsPostAsyncWithHttpInfo
     *
     * Processes a sale transaction for either ACH or credit card.
     *
     * @param  \Tns\EpayPolicy\Model\PostTransactionRequestModelV1 $post_transaction_request_model The details of the transaction to be processed. In the response, the Id of the created transaction is the last part of the URI in the location header attribute. (required)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transactionsPostAsyncWithHttpInfo($post_transaction_request_model, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsPost'][0])
    {
        $returnType = '';
        $request = $this->transactionsPostRequest($post_transaction_request_model, $impersonation_account_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'transactionsPost'
     *
     * @param  \Tns\EpayPolicy\Model\PostTransactionRequestModelV1 $post_transaction_request_model The details of the transaction to be processed. In the response, the Id of the created transaction is the last part of the URI in the location header attribute. (required)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function transactionsPostRequest($post_transaction_request_model, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsPost'][0])
    {

        // verify the required parameter 'post_transaction_request_model' is set
        if ($post_transaction_request_model === null || (is_array($post_transaction_request_model) && count($post_transaction_request_model) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_transaction_request_model when calling transactionsPost'
            );
        }



        $resourcePath = '/api/v1/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($impersonation_account_key !== null) {
            $headerParams['impersonationAccountKey'] = ObjectSerializer::toHeaderValue($impersonation_account_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', 'application/xml', 'text/xml', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_transaction_request_model)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_transaction_request_model));
            } else {
                $httpBody = $post_transaction_request_model;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation transactionsRefund
     *
     * Processes a refund of a transaction.
     *
     * @param  int $id The Id of the transaction. (required)
     * @param  \Tns\EpayPolicy\Model\PostRefundTransactionRequestModel $post_refund_transaction_request_model The details of how to process the refund. (required)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsRefund'] to see the possible values for this operation
     *
     * @throws \Tns\EpayPolicy\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function transactionsRefund($id, $post_refund_transaction_request_model, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsRefund'][0])
    {
        $this->transactionsRefundWithHttpInfo($id, $post_refund_transaction_request_model, $impersonation_account_key, $contentType);
    }

    /**
     * Operation transactionsRefundWithHttpInfo
     *
     * Processes a refund of a transaction.
     *
     * @param  int $id The Id of the transaction. (required)
     * @param  \Tns\EpayPolicy\Model\PostRefundTransactionRequestModel $post_refund_transaction_request_model The details of how to process the refund. (required)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsRefund'] to see the possible values for this operation
     *
     * @throws \Tns\EpayPolicy\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function transactionsRefundWithHttpInfo($id, $post_refund_transaction_request_model, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsRefund'][0])
    {
        $request = $this->transactionsRefundRequest($id, $post_refund_transaction_request_model, $impersonation_account_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tns\EpayPolicy\Model\PostRefundTransactionResponseModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation transactionsRefundAsync
     *
     * Processes a refund of a transaction.
     *
     * @param  int $id The Id of the transaction. (required)
     * @param  \Tns\EpayPolicy\Model\PostRefundTransactionRequestModel $post_refund_transaction_request_model The details of how to process the refund. (required)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsRefund'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transactionsRefundAsync($id, $post_refund_transaction_request_model, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsRefund'][0])
    {
        return $this->transactionsRefundAsyncWithHttpInfo($id, $post_refund_transaction_request_model, $impersonation_account_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation transactionsRefundAsyncWithHttpInfo
     *
     * Processes a refund of a transaction.
     *
     * @param  int $id The Id of the transaction. (required)
     * @param  \Tns\EpayPolicy\Model\PostRefundTransactionRequestModel $post_refund_transaction_request_model The details of how to process the refund. (required)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsRefund'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transactionsRefundAsyncWithHttpInfo($id, $post_refund_transaction_request_model, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsRefund'][0])
    {
        $returnType = '';
        $request = $this->transactionsRefundRequest($id, $post_refund_transaction_request_model, $impersonation_account_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'transactionsRefund'
     *
     * @param  int $id The Id of the transaction. (required)
     * @param  \Tns\EpayPolicy\Model\PostRefundTransactionRequestModel $post_refund_transaction_request_model The details of how to process the refund. (required)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsRefund'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function transactionsRefundRequest($id, $post_refund_transaction_request_model, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsRefund'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling transactionsRefund'
            );
        }

        // verify the required parameter 'post_refund_transaction_request_model' is set
        if ($post_refund_transaction_request_model === null || (is_array($post_refund_transaction_request_model) && count($post_refund_transaction_request_model) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_refund_transaction_request_model when calling transactionsRefund'
            );
        }



        $resourcePath = '/api/v1/transactions/{id}/refund';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($impersonation_account_key !== null) {
            $headerParams['impersonationAccountKey'] = ObjectSerializer::toHeaderValue($impersonation_account_key);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', 'application/xml', 'text/xml', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_refund_transaction_request_model)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_refund_transaction_request_model));
            } else {
                $httpBody = $post_refund_transaction_request_model;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation transactionsSearch
     *
     * Retrieves a list of Transactions based on search parameters.
     *
     * @param  \DateTime $begin_date When filtering by date, the earliest permitted date. Default is 30 days ago. This parameter is ignored if beginCreateDate or endCreateDate is provided. (optional)
     * @param  \DateTime $end_date When filtering by date, the latest permitted date. Default is now. This parameter is ignored if beginCreateDate or endCreateDate is provided. (optional)
     * @param  \DateTime $begin_create_date When filtering by create date, the earliest permitted date. Default is null, unless endCreateDate provided then default is 30 days ago. (optional)
     * @param  \DateTime $end_create_date When filtering by create date, the latest permitted date. Default is null. (optional)
     * @param  string $transaction_search_type_id The type of transaction search to perform. Default is Processed. (optional)
     * @param  float $min_amount When filtering by amount, the minimum permitted amount. (optional)
     * @param  float $max_amount When filtering by amount, the maximum permitted amount. (optional)
     * @param  string $account_number When filtering by payment method details, the last four digits of the payment method&#39;s account number. (optional)
     * @param  string $payer_name When filtering by the payer&#39;s name, the name or partial name to match. (optional)
     * @param  int $batch_id When filtering by batch, the id of the batch. (optional)
     * @param  int $page The page of results to return. Default is 1. (optional)
     * @param  string $page_size The size of each page. Default is 25, Maximum is 50. (optional)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsSearch'] to see the possible values for this operation
     *
     * @throws \Tns\EpayPolicy\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Tns\EpayPolicy\Model\GetTransactionsResponseModel|array<string,object>
     */
    public function transactionsSearch($begin_date = null, $end_date = null, $begin_create_date = null, $end_create_date = null, $transaction_search_type_id = null, $min_amount = null, $max_amount = null, $account_number = null, $payer_name = null, $batch_id = null, $page = null, $page_size = null, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsSearch'][0])
    {
        list($response) = $this->transactionsSearchWithHttpInfo($begin_date, $end_date, $begin_create_date, $end_create_date, $transaction_search_type_id, $min_amount, $max_amount, $account_number, $payer_name, $batch_id, $page, $page_size, $impersonation_account_key, $contentType);
        return $response;
    }

    /**
     * Operation transactionsSearchWithHttpInfo
     *
     * Retrieves a list of Transactions based on search parameters.
     *
     * @param  \DateTime $begin_date When filtering by date, the earliest permitted date. Default is 30 days ago. This parameter is ignored if beginCreateDate or endCreateDate is provided. (optional)
     * @param  \DateTime $end_date When filtering by date, the latest permitted date. Default is now. This parameter is ignored if beginCreateDate or endCreateDate is provided. (optional)
     * @param  \DateTime $begin_create_date When filtering by create date, the earliest permitted date. Default is null, unless endCreateDate provided then default is 30 days ago. (optional)
     * @param  \DateTime $end_create_date When filtering by create date, the latest permitted date. Default is null. (optional)
     * @param  string $transaction_search_type_id The type of transaction search to perform. Default is Processed. (optional)
     * @param  float $min_amount When filtering by amount, the minimum permitted amount. (optional)
     * @param  float $max_amount When filtering by amount, the maximum permitted amount. (optional)
     * @param  string $account_number When filtering by payment method details, the last four digits of the payment method&#39;s account number. (optional)
     * @param  string $payer_name When filtering by the payer&#39;s name, the name or partial name to match. (optional)
     * @param  int $batch_id When filtering by batch, the id of the batch. (optional)
     * @param  int $page The page of results to return. Default is 1. (optional)
     * @param  string $page_size The size of each page. Default is 25, Maximum is 50. (optional)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsSearch'] to see the possible values for this operation
     *
     * @throws \Tns\EpayPolicy\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Tns\EpayPolicy\Model\GetTransactionsResponseModel|array<string,object>, HTTP status code, HTTP response headers (array of strings)
     */
    public function transactionsSearchWithHttpInfo($begin_date = null, $end_date = null, $begin_create_date = null, $end_create_date = null, $transaction_search_type_id = null, $min_amount = null, $max_amount = null, $account_number = null, $payer_name = null, $batch_id = null, $page = null, $page_size = null, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsSearch'][0])
    {
        $request = $this->transactionsSearchRequest($begin_date, $end_date, $begin_create_date, $end_create_date, $transaction_search_type_id, $min_amount, $max_amount, $account_number, $payer_name, $batch_id, $page, $page_size, $impersonation_account_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Tns\EpayPolicy\Model\GetTransactionsResponseModel' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tns\EpayPolicy\Model\GetTransactionsResponseModel' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tns\EpayPolicy\Model\GetTransactionsResponseModel', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('array<string,object>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,object>' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,object>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Tns\EpayPolicy\Model\GetTransactionsResponseModel';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tns\EpayPolicy\Model\GetTransactionsResponseModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,object>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation transactionsSearchAsync
     *
     * Retrieves a list of Transactions based on search parameters.
     *
     * @param  \DateTime $begin_date When filtering by date, the earliest permitted date. Default is 30 days ago. This parameter is ignored if beginCreateDate or endCreateDate is provided. (optional)
     * @param  \DateTime $end_date When filtering by date, the latest permitted date. Default is now. This parameter is ignored if beginCreateDate or endCreateDate is provided. (optional)
     * @param  \DateTime $begin_create_date When filtering by create date, the earliest permitted date. Default is null, unless endCreateDate provided then default is 30 days ago. (optional)
     * @param  \DateTime $end_create_date When filtering by create date, the latest permitted date. Default is null. (optional)
     * @param  string $transaction_search_type_id The type of transaction search to perform. Default is Processed. (optional)
     * @param  float $min_amount When filtering by amount, the minimum permitted amount. (optional)
     * @param  float $max_amount When filtering by amount, the maximum permitted amount. (optional)
     * @param  string $account_number When filtering by payment method details, the last four digits of the payment method&#39;s account number. (optional)
     * @param  string $payer_name When filtering by the payer&#39;s name, the name or partial name to match. (optional)
     * @param  int $batch_id When filtering by batch, the id of the batch. (optional)
     * @param  int $page The page of results to return. Default is 1. (optional)
     * @param  string $page_size The size of each page. Default is 25, Maximum is 50. (optional)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transactionsSearchAsync($begin_date = null, $end_date = null, $begin_create_date = null, $end_create_date = null, $transaction_search_type_id = null, $min_amount = null, $max_amount = null, $account_number = null, $payer_name = null, $batch_id = null, $page = null, $page_size = null, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsSearch'][0])
    {
        return $this->transactionsSearchAsyncWithHttpInfo($begin_date, $end_date, $begin_create_date, $end_create_date, $transaction_search_type_id, $min_amount, $max_amount, $account_number, $payer_name, $batch_id, $page, $page_size, $impersonation_account_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation transactionsSearchAsyncWithHttpInfo
     *
     * Retrieves a list of Transactions based on search parameters.
     *
     * @param  \DateTime $begin_date When filtering by date, the earliest permitted date. Default is 30 days ago. This parameter is ignored if beginCreateDate or endCreateDate is provided. (optional)
     * @param  \DateTime $end_date When filtering by date, the latest permitted date. Default is now. This parameter is ignored if beginCreateDate or endCreateDate is provided. (optional)
     * @param  \DateTime $begin_create_date When filtering by create date, the earliest permitted date. Default is null, unless endCreateDate provided then default is 30 days ago. (optional)
     * @param  \DateTime $end_create_date When filtering by create date, the latest permitted date. Default is null. (optional)
     * @param  string $transaction_search_type_id The type of transaction search to perform. Default is Processed. (optional)
     * @param  float $min_amount When filtering by amount, the minimum permitted amount. (optional)
     * @param  float $max_amount When filtering by amount, the maximum permitted amount. (optional)
     * @param  string $account_number When filtering by payment method details, the last four digits of the payment method&#39;s account number. (optional)
     * @param  string $payer_name When filtering by the payer&#39;s name, the name or partial name to match. (optional)
     * @param  int $batch_id When filtering by batch, the id of the batch. (optional)
     * @param  int $page The page of results to return. Default is 1. (optional)
     * @param  string $page_size The size of each page. Default is 25, Maximum is 50. (optional)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transactionsSearchAsyncWithHttpInfo($begin_date = null, $end_date = null, $begin_create_date = null, $end_create_date = null, $transaction_search_type_id = null, $min_amount = null, $max_amount = null, $account_number = null, $payer_name = null, $batch_id = null, $page = null, $page_size = null, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsSearch'][0])
    {
        $returnType = '\Tns\EpayPolicy\Model\GetTransactionsResponseModel';
        $request = $this->transactionsSearchRequest($begin_date, $end_date, $begin_create_date, $end_create_date, $transaction_search_type_id, $min_amount, $max_amount, $account_number, $payer_name, $batch_id, $page, $page_size, $impersonation_account_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'transactionsSearch'
     *
     * @param  \DateTime $begin_date When filtering by date, the earliest permitted date. Default is 30 days ago. This parameter is ignored if beginCreateDate or endCreateDate is provided. (optional)
     * @param  \DateTime $end_date When filtering by date, the latest permitted date. Default is now. This parameter is ignored if beginCreateDate or endCreateDate is provided. (optional)
     * @param  \DateTime $begin_create_date When filtering by create date, the earliest permitted date. Default is null, unless endCreateDate provided then default is 30 days ago. (optional)
     * @param  \DateTime $end_create_date When filtering by create date, the latest permitted date. Default is null. (optional)
     * @param  string $transaction_search_type_id The type of transaction search to perform. Default is Processed. (optional)
     * @param  float $min_amount When filtering by amount, the minimum permitted amount. (optional)
     * @param  float $max_amount When filtering by amount, the maximum permitted amount. (optional)
     * @param  string $account_number When filtering by payment method details, the last four digits of the payment method&#39;s account number. (optional)
     * @param  string $payer_name When filtering by the payer&#39;s name, the name or partial name to match. (optional)
     * @param  int $batch_id When filtering by batch, the id of the batch. (optional)
     * @param  int $page The page of results to return. Default is 1. (optional)
     * @param  string $page_size The size of each page. Default is 25, Maximum is 50. (optional)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function transactionsSearchRequest($begin_date = null, $end_date = null, $begin_create_date = null, $end_create_date = null, $transaction_search_type_id = null, $min_amount = null, $max_amount = null, $account_number = null, $payer_name = null, $batch_id = null, $page = null, $page_size = null, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsSearch'][0])
    {















        $resourcePath = '/api/v1/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $begin_date,
            'beginDate', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $begin_create_date,
            'beginCreateDate', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_create_date,
            'endCreateDate', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transaction_search_type_id,
            'transactionSearchTypeId', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_amount,
            'minAmount', // param base name
            'number', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_amount,
            'maxAmount', // param base name
            'number', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_number,
            'accountNumber', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payer_name,
            'payerName', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $batch_id,
            'batchId', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'pageSize', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);

        // header params
        if ($impersonation_account_key !== null) {
            $headerParams['impersonationAccountKey'] = ObjectSerializer::toHeaderValue($impersonation_account_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', 'application/xml', 'text/xml', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation transactionsVoid
     *
     * Processes a void of a transaction.
     *
     * @param  int $id The Id of the transaction. (required)
     * @param  \Tns\EpayPolicy\Model\PostVoidTransactionRequestModel $post_void_transaction_request_model The details of how to process the void. (required)
     * @param  bool $send_receipt [Deprecated. Please use the postVoidTransactionRequestModel parameter.] Set to true if a receipt should be sent to all parties upon a successful void. (optional)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsVoid'] to see the possible values for this operation
     *
     * @throws \Tns\EpayPolicy\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function transactionsVoid($id, $post_void_transaction_request_model, $send_receipt = null, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsVoid'][0])
    {
        $this->transactionsVoidWithHttpInfo($id, $post_void_transaction_request_model, $send_receipt, $impersonation_account_key, $contentType);
    }

    /**
     * Operation transactionsVoidWithHttpInfo
     *
     * Processes a void of a transaction.
     *
     * @param  int $id The Id of the transaction. (required)
     * @param  \Tns\EpayPolicy\Model\PostVoidTransactionRequestModel $post_void_transaction_request_model The details of how to process the void. (required)
     * @param  bool $send_receipt [Deprecated. Please use the postVoidTransactionRequestModel parameter.] Set to true if a receipt should be sent to all parties upon a successful void. (optional)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsVoid'] to see the possible values for this operation
     *
     * @throws \Tns\EpayPolicy\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function transactionsVoidWithHttpInfo($id, $post_void_transaction_request_model, $send_receipt = null, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsVoid'][0])
    {
        $request = $this->transactionsVoidRequest($id, $post_void_transaction_request_model, $send_receipt, $impersonation_account_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tns\EpayPolicy\Model\PostVoidTransactionResponseModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation transactionsVoidAsync
     *
     * Processes a void of a transaction.
     *
     * @param  int $id The Id of the transaction. (required)
     * @param  \Tns\EpayPolicy\Model\PostVoidTransactionRequestModel $post_void_transaction_request_model The details of how to process the void. (required)
     * @param  bool $send_receipt [Deprecated. Please use the postVoidTransactionRequestModel parameter.] Set to true if a receipt should be sent to all parties upon a successful void. (optional)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsVoid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transactionsVoidAsync($id, $post_void_transaction_request_model, $send_receipt = null, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsVoid'][0])
    {
        return $this->transactionsVoidAsyncWithHttpInfo($id, $post_void_transaction_request_model, $send_receipt, $impersonation_account_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation transactionsVoidAsyncWithHttpInfo
     *
     * Processes a void of a transaction.
     *
     * @param  int $id The Id of the transaction. (required)
     * @param  \Tns\EpayPolicy\Model\PostVoidTransactionRequestModel $post_void_transaction_request_model The details of how to process the void. (required)
     * @param  bool $send_receipt [Deprecated. Please use the postVoidTransactionRequestModel parameter.] Set to true if a receipt should be sent to all parties upon a successful void. (optional)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsVoid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transactionsVoidAsyncWithHttpInfo($id, $post_void_transaction_request_model, $send_receipt = null, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsVoid'][0])
    {
        $returnType = '';
        $request = $this->transactionsVoidRequest($id, $post_void_transaction_request_model, $send_receipt, $impersonation_account_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'transactionsVoid'
     *
     * @param  int $id The Id of the transaction. (required)
     * @param  \Tns\EpayPolicy\Model\PostVoidTransactionRequestModel $post_void_transaction_request_model The details of how to process the void. (required)
     * @param  bool $send_receipt [Deprecated. Please use the postVoidTransactionRequestModel parameter.] Set to true if a receipt should be sent to all parties upon a successful void. (optional)
     * @param  string $impersonation_account_key The key that allows impersonation of another account for which the transaction is being processed. Only specify a value if the account being impersonated is different from the account that is submitting this request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transactionsVoid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function transactionsVoidRequest($id, $post_void_transaction_request_model, $send_receipt = null, $impersonation_account_key = null, string $contentType = self::contentTypes['transactionsVoid'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling transactionsVoid'
            );
        }

        // verify the required parameter 'post_void_transaction_request_model' is set
        if ($post_void_transaction_request_model === null || (is_array($post_void_transaction_request_model) && count($post_void_transaction_request_model) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_void_transaction_request_model when calling transactionsVoid'
            );
        }




        $resourcePath = '/api/v1/transactions/{id}/void';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $send_receipt,
            'sendReceipt', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);

        // header params
        if ($impersonation_account_key !== null) {
            $headerParams['impersonationAccountKey'] = ObjectSerializer::toHeaderValue($impersonation_account_key);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', 'application/xml', 'text/xml', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_void_transaction_request_model)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_void_transaction_request_model));
            } else {
                $httpBody = $post_void_transaction_request_model;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
